"use client"

import { useEffect, useRef, useState, useMemo } from 'react'
import dynamic from 'next/dynamic'
import { apiService, DRTModelType } from '@/lib/api'

// Dynamically import Leaflet to avoid SSR issues
const L = typeof window !== 'undefined' ? require('leaflet') : null

// Fix for default markers in Leaflet - only on client side
if (typeof window !== 'undefined' && L) {
  delete (L.Icon.Default.prototype as any)._getIconUrl
  L.Icon.Default.mergeOptions({
    iconRetinaUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon-2x.png',
    iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon.png',
    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png',
  })
}

// Î™®Îç∏ Îß§Ìïë
const modelTypeMapping: Record<string, DRTModelType> = {
  "ÍµêÌÜµÏ∑®ÏïΩÏßÄ": "vulnerable",
  "Ï∂úÌá¥Í∑º": "commuter", 
  "Í¥ÄÍ¥ëÌòï": "tourism"
}

// Ï†ÅÌï©ÏÑ± Ï†êÏàòÎ≥Ñ ÏÉâÏÉÅ
const getSuitabilityColor = (score: number): string => {
  if (score >= 80) return '#22C55E' // Green - Very Suitable
  if (score >= 60) return '#EAB308' // Yellow - Suitable
  if (score >= 40) return '#F97316' // Orange - Fair
  return '#EF4444' // Red - Unsuitable
}

// Ï†ÅÌï©ÏÑ± Î†àÎ≤® ÌÖçÏä§Ìä∏
const getSuitabilityLevel = (score: number): string => {
  if (score >= 80) return 'Îß§Ïö∞ Ï†ÅÌï©'
  if (score >= 60) return 'Ï†ÅÌï©'
  if (score >= 40) return 'Î≥¥ÌÜµ'
  return 'Î∂ÄÏ†ÅÌï©'
}

interface ModelSuitabilityMapProps {
  selectedModel: string
  onDistrictAnalysis?: (districtName: string, analysis: any) => void
}

interface DistrictAnalysis {
  districtName: string
  selectedModelScore: number
  allModelScores: Record<string, number>
  bestModel: string
  bestScore: number
  suitabilityLevel: string
  suitabilityColor: string
}

function ModelSuitabilityMapComponent({ 
  selectedModel, 
  onDistrictAnalysis 
}: ModelSuitabilityMapProps) {
  const mapRef = useRef<HTMLDivElement>(null)
  const mapInstanceRef = useRef<any>(null)
  const [isClient, setIsClient] = useState(false)
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [selectedDistrict, setSelectedDistrict] = useState<string | null>(null)
  const [districtScores, setDistrictScores] = useState<Record<string, Record<string, number>>>({})

  // Seoul bounds for initial view
  const seoulBounds: [number, number] = [37.5665, 126.9780]

  // Check if we're on client side
  useEffect(() => {
    setIsClient(true)
  }, [])

  // ÏÑ†ÌÉùÎêú Î™®Îç∏Ïóê Îî∞Î•∏ Íµ¨Î≥Ñ ÏÉâÏÉÅ Í≥ÑÏÇ∞
  const getDistrictColor = (districtName: string) => {
    const modelType = modelTypeMapping[selectedModel]
    const score = districtScores[districtName]?.[modelType] || 0
    return getSuitabilityColor(score)
  }

  // Style function for districts
  const getFeatureStyle = (feature: any) => {
    const districtName = feature.properties.sggnm
    const isSelected = selectedDistrict === districtName
    const fillColor = getDistrictColor(districtName)

    return {
      fillColor: fillColor,
      weight: isSelected ? 3 : 2,
      opacity: 1,
      color: isSelected ? '#2563EB' : '#ffffff',
      dashArray: '',
      fillOpacity: 0.7
    }
  }

  // Íµ¨ ÌÅ¥Î¶≠ Ïãú Î™®Îì† Î™®Îç∏Ïùò Ï†êÏàò Í∞ÄÏ†∏Ïò§Í∏∞
  const analyzeDistrict = async (districtName: string) => {
    try {
      console.log('üîç Analyzing district:', districtName)
      
      // 3Í∞ú Î™®Îç∏ Î™®ÎëêÏóê ÎåÄÌï¥ Ï†êÏàò Í∞ÄÏ†∏Ïò§Í∏∞
      const modelPromises = Object.entries(modelTypeMapping).map(async ([modelName, modelType]) => {
        try {
          const response = await apiService.getDRTScores(districtName, modelType, "2025-09-01")
          const avgScore = response.top_stations.length > 0 
            ? response.top_stations.reduce((sum, station) => sum + station.drt_score, 0) / response.top_stations.length
            : 0
          return { modelName, modelType, score: avgScore }
        } catch (err) {
          console.warn(`Failed to get score for ${districtName} - ${modelType}:`, err)
          return { modelName, modelType, score: 0 }
        }
      })

      const results = await Promise.all(modelPromises)
      
      // Í≤∞Í≥º Ï†ïÎ¶¨
      const allScores: Record<string, number> = {}
      results.forEach(({ modelName, score }) => {
        allScores[modelName] = score
      })

      // ÏµúÍ≥† Ï†êÏàò Î™®Îç∏ Ï∞æÍ∏∞
      const bestModel = Object.entries(allScores).reduce((best, [model, score]) => 
        score > best.score ? { model, score } : best, 
        { model: 'ÍµêÌÜµÏ∑®ÏïΩÏßÄ', score: 0 }
      )

      const selectedModelScore = allScores[selectedModel] || 0

      const analysis: DistrictAnalysis = {
        districtName,
        selectedModelScore,
        allModelScores: allScores,
        bestModel: bestModel.model,
        bestScore: bestModel.score,
        suitabilityLevel: getSuitabilityLevel(selectedModelScore),
        suitabilityColor: getSuitabilityColor(selectedModelScore)
      }

      console.log('üìä District analysis result:', analysis)

      // Ï†êÏàò Ï∫êÏãú ÏóÖÎç∞Ïù¥Ìä∏
      setDistrictScores(prev => ({
        ...prev,
        [districtName]: Object.fromEntries(
          results.map(({ modelType, score }) => [modelType, score])
        )
      }))

      // Î∂ÑÏÑù Í≤∞Í≥º ÏΩúÎ∞± Ìò∏Ï∂ú
      if (onDistrictAnalysis) {
        onDistrictAnalysis(districtName, analysis)
      }

    } catch (err) {
      console.error('üö® District analysis error:', err)
    }
  }

  useEffect(() => {
    if (!isClient || !L || !mapRef.current || mapInstanceRef.current) return

    console.log('üó∫Ô∏è Initializing model suitability map...')

    // Initialize map with CartoDB Positron style
    const map = L.map(mapRef.current, {
      center: seoulBounds,
      zoom: 11,
      zoomControl: true,
      attributionControl: true
    })

    // CartoDB Positron tiles
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
      subdomains: 'abcd',
      maxZoom: 19
    }).addTo(map)

    mapInstanceRef.current = map

    // Load GeoJSON data
    const loadGeoJSON = async () => {
      try {
        setIsLoading(true)
        setError(null)

        const response = await fetch('/seoul-districts-simple.geojson')
        if (!response.ok) {
          throw new Error(`Failed to load GeoJSON: ${response.status}`)
        }

        const geoJsonData = await response.json()
        
        // Add all district features to map
        const layer = L.geoJSON(geoJsonData, {
          style: getFeatureStyle,
          onEachFeature: (feature, layer) => {
            const districtName = feature.properties.sggnm

            // Mouse events
            layer.on({
              mouseover: (e) => {
                const layer = e.target
                layer.setStyle({
                  weight: 3,
                  color: '#2563EB',
                  fillOpacity: 0.9
                })
                layer.bringToFront()
              },
              mouseout: (e) => {
                const layer = e.target
                layer.setStyle(getFeatureStyle(feature))
              },
              click: (e) => {
                const districtName = feature.properties.sggnm
                
                // Update selected district
                setSelectedDistrict(districtName)
                
                // Zoom to district
                map.fitBounds(layer.getBounds())
                
                // Analyze district for all models
                analyzeDistrict(districtName)
              }
            })

            // Initial tooltip
            layer.bindTooltip(
              `<div>
                <strong>${districtName}</strong><br/>
                ÌÅ¥Î¶≠ÌïòÏó¨ ${selectedModel} Î™®Îç∏ Ï†ÅÌï©ÏÑ± Î∂ÑÏÑù
              </div>`,
              {
                permanent: false,
                direction: 'center',
                className: 'district-tooltip'
              }
            )
          }
        }).addTo(map)

        setIsLoading(false)
      } catch (err) {
        console.error('Failed to load GeoJSON:', err)
        setError(err instanceof Error ? err.message : 'Failed to load map data')
        setIsLoading(false)
      }
    }

    loadGeoJSON()

    // Cleanup function
    return () => {
      if (mapInstanceRef.current) {
        mapInstanceRef.current.remove()
        mapInstanceRef.current = null
      }
    }
  }, [isClient])

  // Update styles when model changes
  useEffect(() => {
    if (!isClient || !L || !mapInstanceRef.current) return

    console.log('üîÑ Updating map styles for model:', selectedModel)

    mapInstanceRef.current.eachLayer((layer: any) => {
      if (layer instanceof L.GeoJSON) {
        layer.eachLayer((featureLayer: any) => {
          if (featureLayer instanceof L.Path) {
            const feature = featureLayer.feature
            if (feature) {
              // Update style
              featureLayer.setStyle(getFeatureStyle(feature))
              
              // Update tooltip
              const districtName = feature.properties.sggnm
              featureLayer.setTooltipContent(
                `<div>
                  <strong>${districtName}</strong><br/>
                  ÌÅ¥Î¶≠ÌïòÏó¨ ${selectedModel} Î™®Îç∏ Ï†ÅÌï©ÏÑ± Î∂ÑÏÑù
                </div>`
              )
            }
          }
        })
      }
    })
  }, [selectedModel, districtScores, selectedDistrict, isClient])

  if (error) {
    return (
      <div className="h-[400px] bg-gray-100 rounded-lg flex items-center justify-center">
        <div className="text-center text-red-500">
          <p className="font-medium">ÏßÄÎèÑ Î°úÎî© Ïã§Ìå®</p>
          <p className="text-sm">{error}</p>
        </div>
      </div>
    )
  }

  // Don't render anything on server side
  if (!isClient) {
    return (
      <div className="h-[400px] bg-gray-100 rounded-lg flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-2"></div>
          <p className="text-gray-600">ÏßÄÎèÑ Î°úÎî© Ï§ë...</p>
        </div>
      </div>
    )
  }

  return (
    <div className="relative">
      <div 
        ref={mapRef} 
        className="h-[400px] rounded-lg border"
        style={{ zIndex: 1 }}
      />
      
      {isLoading && (
        <div className="absolute inset-0 bg-gray-100 rounded-lg flex items-center justify-center z-10">
          <div className="text-center">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-2"></div>
            <p className="text-gray-600">ÏßÄÎèÑ Î°úÎî© Ï§ë...</p>
          </div>
        </div>
      )}

      {/* Model Suitability Legend */}
      <div className="absolute bottom-4 left-4 bg-white/90 backdrop-blur-sm rounded-lg p-3 shadow-lg text-xs z-20">
        <div className="font-medium mb-2">{selectedModel} Î™®Îç∏ Ï†ÅÌï©ÏÑ±</div>
        <div className="space-y-1">
          <div className="flex items-center gap-2">
            <div className="w-4 h-3 bg-[#22C55E] rounded-sm"></div>
            <span>Îß§Ïö∞ Ï†ÅÌï© (80Ï†ê Ïù¥ÏÉÅ)</span>
          </div>
          <div className="flex items-center gap-2">
            <div className="w-4 h-3 bg-[#EAB308] rounded-sm"></div>
            <span>Ï†ÅÌï© (60-80Ï†ê)</span>
          </div>
          <div className="flex items-center gap-2">
            <div className="w-4 h-3 bg-[#F97316] rounded-sm"></div>
            <span>Î≥¥ÌÜµ (40-60Ï†ê)</span>
          </div>
          <div className="flex items-center gap-2">
            <div className="w-4 h-3 bg-[#EF4444] rounded-sm"></div>
            <span>Î∂ÄÏ†ÅÌï© (40Ï†ê ÎØ∏Îßå)</span>
          </div>
        </div>
      </div>

      {/* Instructions */}
      <div className="absolute top-4 right-4 bg-white/90 backdrop-blur-sm rounded-lg p-3 shadow-sm z-20">
        <div className="text-xs">
          <div className="font-medium text-blue-600">üí° ÏÇ¨Ïö©Î≤ï</div>
          <div className="text-gray-600">Íµ¨Î•º ÌÅ¥Î¶≠ÌïòÏó¨</div>
          <div className="text-gray-600">Î™®Îç∏ Ï†ÅÌï©ÏÑ± Î∂ÑÏÑù</div>
        </div>
      </div>

      {/* Selected District Info */}
      {selectedDistrict && (
        <div className="absolute top-4 left-4 bg-white/90 backdrop-blur-sm rounded-lg p-3 shadow-sm z-20">
          <div className="text-xs">
            <div className="font-medium">üìç ÏÑ†ÌÉùÎêú Íµ¨</div>
            <div className="text-blue-600 font-bold">{selectedDistrict}</div>
            <div className="text-gray-500">Î∂ÑÏÑù Ï§ë...</div>
          </div>
        </div>
      )}
    </div>
  )
}

// Export as dynamic component to prevent SSR issues
export const ModelSuitabilityMap = dynamic(() => Promise.resolve(ModelSuitabilityMapComponent), {
  ssr: false,
  loading: () => (
    <div className="h-[400px] bg-gray-100 rounded-lg flex items-center justify-center">
      <div className="text-center">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-2"></div>
        <p className="text-gray-600">Î™®Îç∏ Ï†ÅÌï©ÏÑ± ÏßÄÎèÑ Î°úÎî© Ï§ë...</p>
      </div>
    </div>
  )
})